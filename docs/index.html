<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>symbol_math API documentation</title>
<meta name="description" content="A symbolic math API â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>symbol_math</code></h1>
</header>
<section id="section-intro">
<p>A symbolic math API.</p>
<p>This module is a simple library of tools to make symbolic computations and basic operations on algebraic functions.</p>
<p>Symbolic calculation is a valuable tool in math. This library enables you to create mathematical functions in one
variable and do basic computations with them, like simplifying, evaluating, taking the derivative and evaluating finite
integrals.</p>
<h2 id="example">Example</h2>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; import symbol_math
&gt;&gt;&gt; f = symbol_math.Function("x^2+x+3x", "x")
&gt;&gt;&gt; print(f.simplify())
x^2 + 4*x
&gt;&gt;&gt; print(f.derivative())
4 + 2*x
&gt;&gt;&gt; g = Function("exp(y)", "y")
&gt;&gt;&gt; print(f.change_variable("y"))
y^2 + 4*y
&gt;&gt;&gt; print(f+g)
y^2 + 4*y + exp(y)
&gt;&gt;&gt; f.evaluate(3)
21.0
&gt;&gt;&gt; g.finite_integration(0, 1, tol=1e-5)
1.7182818298909466
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Samuel Eriksson Lidbrink Grudat20
&#34;&#34;&#34;A symbolic math API.

This module is a simple library of tools to make symbolic computations and basic operations on algebraic functions.

Symbolic calculation is a valuable tool in math. This library enables you to create mathematical functions in one
variable and do basic computations with them, like simplifying, evaluating, taking the derivative and evaluating finite
integrals.

Example:
    Example usage:

        &gt;&gt;&gt; import symbol_math
        &gt;&gt;&gt; f = symbol_math.Function(&#34;x^2+x+3x&#34;, &#34;x&#34;)
        &gt;&gt;&gt; print(f.simplify())
        x^2 + 4*x
        &gt;&gt;&gt; print(f.derivative())
        4 + 2*x
        &gt;&gt;&gt; g = Function(&#34;exp(y)&#34;, &#34;y&#34;)
        &gt;&gt;&gt; print(f.change_variable(&#34;y&#34;))
        y^2 + 4*y
        &gt;&gt;&gt; print(f+g)
        y^2 + 4*y + exp(y)
        &gt;&gt;&gt; f.evaluate(3)
        21.0
        &gt;&gt;&gt; g.finite_integration(0, 1, tol=1e-5)
        1.7182818298909466
&#34;&#34;&#34;
import math


class Function(object):
    &#34;&#34;&#34;A class for storing functions.


    &#34;&#34;&#34;

    def __init__(self, expression, variable):
        &#34;&#34;&#34;
        Args:
            expression (string): The functions expression. Must be an algebraic expression
            variable (string): The function variable
        Raises:
            TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
        &#34;&#34;&#34;
        _check_expression(expression, variable)
        self._expression = _interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;)
        self.variable = variable

    def simplify(self):
        &#34;&#34;&#34;Simplifies expression to simplest form.
        Returns:
            string: new expression for function
            &#34;&#34;&#34;
        self._expression = _simp_helper(self._expression)
        return self

    def evaluate(self, value):
        &#34;&#34;&#34;Evaluates the function at specified value
        Args:
            value (float, int): Value where function should be evaluated
        Returns:
            float: function evaluation
        &#34;&#34;&#34;
        return evaluate(str(self), self.variable, value)

    def change_variable(self, variable):
        &#34;&#34;&#34;Changes the current function variable to the given variable.
        Args:
            variable (string): New variable for function
        Returns:
            string: New function expression
        &#34;&#34;&#34;
        self.variable = variable
        return self

    def __add__(self, other):
        &#34;&#34;&#34;Addition operator for two functions of the same variables.
        Overloads + operator as addition defined for functions.
        Args:
            other (Function): Other function to be added
        Returns:
            object: the function that is the sum of self and other
        Raises:
             TypeError: If other.variable != self.variable
         &#34;&#34;&#34;
        if other.variable != self.variable:
            raise TypeError(&#34;Functions must have the same variable&#34;)
        return Function(str(self) + &#34;+&#34; + str(other), self.variable)

    def __str__(self):
        &#34;&#34;&#34;String representation.
        Overloads str operator with function expression&#34;&#34;&#34;
        return _fix_out(self._expression, self.variable)

    def derivative(self):
        &#34;&#34;&#34;Calculate derivative of function
        Returns:
            object: the function derivative
        Raises:
             SystemError: Cannot compute derivative internally
         &#34;&#34;&#34;
        der = Function(&#34;1&#34;, self.variable)
        der._expression = _der_helper(self._expression)
        return der

    def finite_integration(self, lower_bound, upper_bound, tol=0.01):
        &#34;&#34;&#34;Calculate derivative of function
        Args:
            lower_bound (float): lower integration bound
            upper_bound (float): upper integration bound
            tol (float): error tolerance for calculation. Must be non-negative
        Returns:
            float: integral of self over lower_bound to upper_bound
        Raises:
            TypeError: If either lower_bound, upper_bound or tol is not of type float
            ValueError: If tol &lt; 0
         &#34;&#34;&#34;
        for arg in [lower_bound, upper_bound, tol]:
            if not isinstance(arg, (float, int)):
                raise TypeError(&#34;Arguments must be floats or ints&#34;)
        if tol &lt; 0:
            raise ValueError(&#34;tol must be positive, not &#34; + str(tol))
        val, prev_val = 0, tol + 1
        exp = 1
        while abs(prev_val-val) &gt; tol:
            prev_val = val
            exp += 1
            n = 10 ** exp
            part_sum = (self.evaluate(lower_bound) + self.evaluate(upper_bound))/2/n
            for k in range(1, n):
                point = lower_bound + k/n* (upper_bound-lower_bound)
                part_sum += self.evaluate(point) * 1/n
            val = part_sum
        return val


COMMON_OPERATORS = [&#34;asinh&#34;, &#34;acosh&#34;, &#34;atanh&#34;, &#34;sinh&#34;, &#34;cosh&#34;, &#34;tanh&#34;, &#34;asin&#34;, &#34;acos&#34;, &#34;atan&#34;, &#34;sin&#34;, &#34;tan&#34;, &#34;cos&#34;,
                    &#34;log&#34;, &#34;exp&#34;]
_OPERATOR_INVERSE = {&#34;sinh&#34;: &#34;asinh&#34;, &#34;cosh&#34;: &#34;acosh&#34;, &#34;tanh&#34;: &#34;atanh&#34;, &#34;asinh&#34;: &#34;sinh&#34;, &#34;acosh&#34;: &#34;cosh&#34;,
                     &#34;atanh&#34;: &#34;tanh&#34;, &#34;sin&#34;: &#34;asin&#34;, &#34;cos&#34;: &#34;acos&#34;, &#34;tan&#34;: &#34;atan&#34;, &#34;asin&#34;: &#34;sin&#34;, &#34;atan&#34;: &#34;tan&#34;,
                     &#34;acos&#34;: &#34;cos&#34;, &#34;log&#34;: &#34;exp&#34;, &#34;exp&#34;: &#34;log&#34;}
_OPERATOR_DERIVATIVE = {&#34;sinh&#34;: &#34;cosh&#34;, &#34;cosh&#34;: &#34;sinh&#34;, &#34;tanh&#34;: [1, &#34;/&#34;, [&#34;cosh&#34;, [&#34;X&#34;]], &#34;^&#34;, 2],
                        &#34;asinh&#34;: [1, &#34;/&#34;, [&#34;X&#34;, &#34;^&#34;, 2, &#34;+&#34;, 1], &#34;^&#34;, 0.5],
                        &#34;acosh&#34;: [1, &#34;/&#34;, [&#34;X&#34;, &#34;^&#34;, 2, &#34;-&#34;, 1], &#34;^&#34;, 0.5],
                     &#34;atanh&#34;: [1, &#34;/&#34;, [1, &#34;-&#34;, &#34;X&#34;, &#34;^&#34;, 2]], &#34;sin&#34;: &#34;cos&#34;, &#34;cos&#34;: &#34;sin&#34;,
                        &#34;tan&#34;: [1, &#34;/&#34;, [&#34;cos&#34;, [&#34;X&#34;]], &#34;^&#34;, 2], &#34;asin&#34;: [1, &#34;/&#34;, [1, &#34;-&#34;, &#34;X&#34;, &#34;^&#34;, 2], &#34;^&#34;, 0.5],
                        &#34;atan&#34;: [1, &#34;/&#34;, [&#34;X&#34;, &#34;^&#34;, 2, &#34;+&#34;, 1]], &#34;acos&#34;: [&#34;-&#34;, 1, &#34;/&#34;, [1, &#34;-&#34;, &#34;X&#34;, &#34;^&#34;, 2], &#34;^&#34;, 0.5],
                        &#34;log&#34;: [1, &#34;/&#34;, &#34;X&#34;], &#34;exp&#34;: &#34;exp&#34;}


def simplify(expression, variable):
    &#34;&#34;&#34;Simplifies expression to simplest form.
    Args:
        expression (string): The expression that should be simplified.
        variable (string): Used variable in expression
    Returns:
        string: simplified expression.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
    &#34;&#34;&#34;
    _check_expression(expression, variable)
    expr_list = _simp_helper(_interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;))
    return _fix_out(expr_list, variable)


def derivative(expression, variable):
    &#34;&#34;&#34;Takes the derivative of the expression.
    Args:
        expression (string): Original expression.
        variable (string): Variable used in expression
    Returns:
        string: Derivative of expression.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
    &#34;&#34;&#34;
    _check_expression(expression, variable)
    expr_list = _der_helper(_interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;))
    return _fix_out(expr_list, variable)


def evaluate(expression, variable, value):
    &#34;&#34;&#34;Evaluates the expression with given variable at value.
    Args:
        expression (string): The expression that should be simplified.
        variable (string): Used variable in expression
        value (float, int): Value where function should be evaluated
    Returns:
        float: evaluation of function.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function&#34;&#34;&#34;
    if not isinstance(value, (float, int)):
        raise TypeError(&#34;Input value must be float or int&#34;)
    _check_expression(expression, variable)
    interp = _interp_expr(expression, variable, value)
    for index in range(0, len(interp)):
        thing = str(interp[index])
        if thing == &#34;^&#34;:
            interp[index] = &#34;**&#34;
        elif thing in COMMON_OPERATORS:
            interp[index] = &#34;math.&#34; + thing
        else:
            interp[index] = thing
    try:
        return float(eval(&#34;&#34;.join(interp)))
    except ZeroDivisionError:
        raise ZeroDivisionError(&#34;float division by zero for expression: &#34; + expression + &#34; at &#34; + variable + &#34; = &#34; +
                                str(value))


def replace_var(expression, old_var, new_var):
    &#34;&#34;&#34;Replaces old variable in expression with a new one, without changing built in functions.
    Args:
        expression (string): The expression that should be simplified.
        old_var (string): Old variable in expression
        new_var (string): New variable to be used
    Returns:
        string: updated expression
    &#34;&#34;&#34;
    return _replace_helper(expression, old_var, new_var, 0)


def _fix_out(expr_list, variable):
    out = &#34;&#34;
    prev = &#34;{&#34;
    for thing in expr_list:
        if (thing == &#34;+&#34; or thing == &#34;-&#34;) and prev != &#34;{&#34; and prev != &#34;(&#34;:
            out += &#34; &#34; + thing + &#34; &#34;
        else:
            out += str(thing)
        prev = thing
    return replace_var(out, &#34;X&#34;, variable)


def _der_helper(expression_list):
    &#34;&#34;&#34;A help function for derivation.&#34;&#34;&#34;

    def der_grouped(group):
        if not var_in(group):
            return [0]
        if &#34;+&#34; not in group and &#34;-&#34; not in group:
            return der_mult(group)
        for index in range(0, len(group)):
            item = group[index]
            if item == &#34;+&#34; or item == &#34;-&#34;:
                if index &gt; 0:
                    return der_grouped(group[:index]) + [item] + der_grouped(group[index+1:])
                else:
                    return [item] + der_grouped(group[index+1:])

    def der_mult(group):
        if not var_in(group):
            return [0]
        if &#34;*&#34; not in group:
            return der_div(group)
        for index in range(0, len(group)):
            if group[index] == &#34;*&#34;:
                return group[:index] + [&#34;*&#34;] + der_mult(group[index+1:]) + [&#34;+&#34;] + group[index+1:] +\
                       [&#34;*&#34;] + der_div(group[:index])

    def der_div(group):
        if not var_in(group):
            return [0]
        if &#34;/&#34; not in group:
            return der_exp(group)
        for index in range(len(group)-1, 0, -1):
            if group[index] == &#34;/&#34;:
                f, g = group[:index], group[index+1:]
                return [der_div(f) + [&#34;*&#34;] + g + [&#34;-&#34;] + f + [&#34;*&#34;] + der_exp(g), &#34;/&#34;] + g + [&#34;^&#34;, 2]

    def der_exp(group):
        if not var_in(group):
            return [0]
        if &#34;^&#34; not in group:
            return der_op(group)
        for index in range(0, len(group)):
            if group[index] == &#34;^&#34;:
                base, exp = group[:index], group[index+1:]
                if not var_in(exp):
                    return exp + [&#34;*&#34;] + base + [&#34;^&#34;, exp + [&#34;-&#34;, 1]]
                elif not var_in(base):
                    return [[&#34;log&#34;, base], &#34;*&#34;, der_par(exp)] + [&#34;*&#34;] + base + [&#34;^&#34;] + exp
                else:
                    return der_mult([[&#34;log&#34;, base], &#34;*&#34;, exp]) + [&#34;*&#34;] + base + [&#34;^&#34;] + exp

    def der_op(group):
        if not var_in(group):
            return [0]
        if len(group) == 2 and isinstance(group[0], str) and group[0] in COMMON_OPERATORS:
            op_der = _OPERATOR_DERIVATIVE[group[0]]
            if isinstance(op_der, str):
                return [[op_der, group[1]], &#34;*&#34;, der_par([group[1]])]
            else:
                return [[x_replacer(op_der, group[1])], &#34;*&#34;, der_par([group[1]])]
        else:
            return der_par(group)

    def der_par(group):
        if not var_in(group):
            return [0]
        if group == &#34;X&#34; or group == [&#34;X&#34;]:
            return [1]
        elif len(group) == 1 and isinstance(group[0], list):
            return der_grouped(group[0])
        else:
            raise SystemError(&#34;Derivation went wrong :(.&#34;)

    def var_in(group):
        for item in group:
            if isinstance(item, list) and var_in(item):
                return True
            elif item == &#34;X&#34;:
                return True
        return False

    def x_replacer(group, instead):
        if not isinstance(group, list) or not var_in(group):
            return group
        for index in range(0, len(group)):
            item = group[index]
            if item == &#34;X&#34;:
                group[index] = instead
            else:
                group[index] = x_replacer(group[index], instead)
        return group

    grouped_list = _group(_basic_fix(expression_list))
    der_group = der_grouped(grouped_list)
    new_list, _ = _sort_and_ungroup(der_group)
    return _simp_helper(new_list)


def _simp_helper(expression_list, mem=None):
    &#34;&#34;&#34;A help function for simplify.&#34;&#34;&#34;
    # memorizes previous result to avoid loops
    if mem is None:
        mem = []
    mem.append(expression_list.copy())
    new_list, _ = _sort_and_ungroup(_group(_basic_fix(expression_list)))
    if len(new_list) == 0:
        return [0]
    fixed_list = _basic_fix(new_list)
    if fixed_list in mem:
        return fixed_list
    else:
        return _simp_helper(fixed_list, mem)


def _basic_fix(list_to_fix):
    &#34;&#34;&#34;does basic simplifications&#34;&#34;&#34;
    prev_expr = []
    while list_to_fix != prev_expr:
        prev_expr = list_to_fix.copy()
        prev_thing = &#34;{&#34;
        par = {0: [&#34;&#34;]}
        par_ok = {0: False}
        par_mult = {}
        par_count = 0
        for index in range(0, len(list_to_fix)):
            thing = list_to_fix[index]
            if index + 1 &lt; len(list_to_fix):
                next_thing = list_to_fix[index + 1]
            else:
                next_thing = &#34;}&#34;

            if _is_int(thing):
                list_to_fix[index] = int(float(thing))
            # Remove redundant expressions
            if (isinstance(prev_thing, str))\
                    and ((thing == 0 and prev_thing in &#34;+-{(&#34; and isinstance(next_thing, str) and next_thing in &#34;+-&#34;)
                         or (thing == 1 and prev_thing == &#34;^&#34;) or (thing == 1 and prev_thing in &#34;*/&#34;)):
                if index - 1 &gt; 0:
                    list_to_fix = list_to_fix[:index - 1] + list_to_fix[index + 1:]
                else:
                    list_to_fix = list_to_fix[index + 1:]
                break
            elif thing == &#34;+&#34; and (isinstance(prev_thing, str) and prev_thing in &#34;*/^&#34;):
                list_to_fix = list_to_fix[:index] + list_to_fix[index + 1:]
                break
            elif thing == &#34;-&#34; and (isinstance(prev_thing, str) and prev_thing in &#34;*/^&#34;):
                if _is_float(next_thing):
                    list_to_fix = list_to_fix[:index] + [-float(next_thing)] + list_to_fix[index + 2:]
                else:
                    list_to_fix = list_to_fix[:index] + [&#34;-&#34;, next_thing] + list_to_fix[index + 2:]

                break
            elif prev_thing == &#34;(&#34; and next_thing == &#34;)&#34;:
                if index-2 &lt; 0 or not isinstance(list_to_fix[index-2], str) or (list_to_fix[index-2] not in
                                                                                COMMON_OPERATORS):
                    if index - 1 &gt; 0:
                        list_to_fix = list_to_fix[:index-1] + [thing] + list_to_fix[index+1:]
                    else:
                        list_to_fix = [thing] + list_to_fix[index+1:]
                    break
            elif thing == &#34;+&#34; and (prev_thing == &#34;{&#34; or prev_thing == &#34;(&#34;):
                if index &gt; 0:
                    list_to_fix = list_to_fix[:index] + list_to_fix[index+1:]
                else:
                    list_to_fix = list_to_fix[index+1:]
                break

            # does basic calculation
            if not isinstance(thing, list):
                if thing == &#34;/&#34; and _is_int(prev_thing) and _is_int(next_thing):
                    divisor = math.gcd(int(prev_thing), int(next_thing))
                    if divisor not in [0, 1]:
                        list_to_fix[index-1] = int(prev_thing)/divisor
                        list_to_fix[index+1] = int(next_thing)/divisor
                        break

            # Remove redundant parenthesis
            for outside in range(par_count, 0, -1):
                if par_ok[outside] and (outside != par_count or thing == &#34;(&#34;):
                    par[outside].append(thing)
            if thing == &#34;(&#34;:
                #if par_ok[par_count]:
                 #   par[par_count].append(&#34;(&#34;)
                par_count += 1
                if prev_thing == &#34;+&#34; or prev_thing == &#34;{&#34;:
                    par[par_count] = par.setdefault(par_count, []) + [&#34;+&#34;]
                    par_ok[par_count] = True
                elif prev_thing == &#34;-&#34;:
                    par[par_count] = par.setdefault(par_count, []) + [&#34;-&#34;]
                    par_ok[par_count] = False
                elif prev_thing == &#34;*&#34; and _is_float(list_to_fix[index-2])\
                        and (index - 3 &lt;= 0 or list_to_fix[index - 3] == &#34;+&#34; or list_to_fix[index-3] == &#34;-&#34;):
                    par_mult[par_count] = list_to_fix[index - 2]
                    if index-3 &lt;= 0 or list_to_fix[index-3] == &#34;+&#34;:
                        par[par_count] = par.setdefault(par_count, []) + [&#34;+&#34;]
                    else:
                        par[par_count] = par.setdefault(par_count, []) + [&#34;-&#34;]
                    par_ok[par_count] = True
                else:
                    par_ok[par_count] = False

            elif thing == &#34;)&#34;:
                if par_ok[par_count] and (isinstance(next_thing, str) and next_thing in &#34;+-}&#34;):
                    content = par[par_count]
                    par_len = len(content)
                    if content[1] == &#34;+&#34; or content[1] == &#34;-&#34;:
                        content = content[1:]
                    to_mult = float(par_mult.setdefault(par_count, 1))
                    if to_mult != 1:
                        multiplied = []
                        in_par = 0
                        for item in content:
                            if item == &#34;(&#34;:
                                in_par += 1
                            elif item == &#34;)&#34;:
                                in_par -= 1
                            if (item == &#34;+&#34; or item == &#34;-&#34;) and in_par == 0:
                                multiplied.extend([item, str(to_mult), &#34;*&#34;])
                            else:
                                multiplied.append(item)
                        content = multiplied
                        par_len += 2
                    if index - par_len -1 &gt; 0:
                        list_to_fix = list_to_fix[:index - par_len-1] + content.copy() + list_to_fix[index + 1:]
                    else:
                        list_to_fix = content.copy() + list_to_fix[index + 1:]
                    break
                par_count -= 1
            elif par_count &gt; 0 and par_ok[par_count]:
                if par[par_count][0] == &#34;-&#34;:
                    if thing == &#34;+&#34;:
                        to_add = &#34;-&#34;
                    elif thing == &#34;-&#34;:
                        to_add = &#34;+&#34;
                    else:
                        to_add = thing
                else:
                    to_add = thing
                par[par_count].append(to_add)

            prev_thing = thing
    return list_to_fix


def _group(list_to_group):
    &#34;&#34;&#34;groups similar object together in preferred order&#34;&#34;&#34;
    first_level = []
    is_first = True
    is_op = False
    op_inv = False
    op = &#34;&#34;
    second_level = []
    par_count = 0
    for item_index in range(0, len(list_to_group)):
        item = list_to_group[item_index]
        if isinstance(item, str) and item in COMMON_OPERATORS and not is_op and is_first:
            is_op = True
            op = item
            if item in _OPERATOR_INVERSE.keys():
                if list_to_group[item_index + 1] == &#34;(&#34; and list_to_group[item_index + 2] == _OPERATOR_INVERSE[item]:
                    op_inv = True
        elif item == &#34;(&#34;:
            if not is_first:
                second_level.append(item)
            par_count += 1
            is_first = False
        elif item == &#34;)&#34;:
            par_count -= 1
            if op_inv and par_count == 1:
                if list_to_group[item_index + 1] != &#34;)&#34;:
                    op_inv = False
            if par_count == 0:
                if is_op:
                    is_op = False
                    if op_inv:
                        first_level.append(_group(second_level[2:-1]))
                        op_inv = False
                    elif second_level[0] == &#34;(&#34; and second_level[-1] == &#34;)&#34;:
                        first_level.append([op, _group(second_level[1:-1])])
                    else:
                        first_level.append([op, _group(second_level)])
                else:
                    first_level.append(_group(second_level))
                is_first = True
                second_level = []
            else:
                second_level.append(item)
        elif is_first:
            first_level.append(item)
        else:
            second_level.append(item)
    return first_level


def _sort_and_ungroup(list_to_fix):
    while len(list_to_fix) == 1 and isinstance(list_to_fix[0], list):
        list_to_fix = list_to_fix[0]
    res = []
    list_to_fix, req_par = _sort_group(list_to_fix.copy())
    for item_index in range(0, len(list_to_fix)):
        item = list_to_fix[item_index]
        if isinstance(item, list):
            nested_list, nest_par = _sort_and_ungroup(item)
            if (item_index + 1 &lt; len(list_to_fix) and list_to_fix[item_index + 1] == &#34;^&#34;) or\
                    (item_index &gt; 0 and isinstance(list_to_fix[item_index - 1], str)
                     and list_to_fix[item_index - 1] in COMMON_OPERATORS):
                nest_par = True
            if res[-1] == &#34;^&#34;:
                nest_par = True
            if nest_par:
                res.append(&#34;(&#34;)
            for nested_item in nested_list:
                res.append(nested_item)
            if nest_par:
                res.append(&#34;)&#34;)
        else:
            res.append(item)
    return res, req_par


def _sort_group(list_to_sort):
    req_par = False
    if len(list_to_sort) == 0 or isinstance(list_to_sort[0], str) and list_to_sort[0] in COMMON_OPERATORS:
        return list_to_sort, req_par
    types = dict()
    cur = []
    prev_sign = 1
    if list_to_sort[0] == &#34;-&#34;:
        prev_sign = -1
    for item_index in range(0, len(list_to_sort)+1):
        if item_index &lt; len(list_to_sort):
            item = list_to_sort[item_index]
        else:
            item = &#34;}&#34;
        if (item == &#34;+&#34; or item == &#34;-&#34; or item == &#34;}&#34;) and\
                (len(cur) &gt; 0 and (item_index - 1 &gt;= 0 and list_to_sort[item_index - 1] != &#34;(&#34;)):
            fixed_part = _fix_mult(cur)
            if len(fixed_part) == 1:
                types[&#34;1&#34;] = [[1], types.setdefault(&#34;1&#34;, [[1], 0])[1] + prev_sign * fixed_part[0]]
            else:
                types[str(fixed_part[2:])] = [fixed_part[2:], types.setdefault(str(fixed_part[2:]), [&#34;&#34;, 0])[1] +
                                              prev_sign * float(fixed_part[0])]
            if item == &#34;+&#34;:
                prev_sign = 1
            elif item == &#34;-&#34;:
                prev_sign = -1
            cur = []
        else:
            cur.append(item)
    res = []
    keys = sorted(types.keys())
    if len(keys) &gt; 1:
        req_par = True
    for dic_key in keys:
        if types[dic_key][1] == 0:
            continue
        elif types[dic_key][1] == 1:
            res.extend([&#34;+&#34;] + types[dic_key][0])
        elif types[dic_key][1] == -1:
            res.extend([&#34;-&#34;] + types[dic_key][0])
        elif types[dic_key][1] &gt; 0:
            res.extend([&#34;+&#34;, types[dic_key][1], &#34;*&#34;] + types[dic_key][0])
        elif types[dic_key][1] &lt; 0:
            res.extend([&#34;-&#34;, -types[dic_key][1], &#34;*&#34;] + types[dic_key][0])
    return res, req_par


def _fix_mult(list_to_fix):
    &#34;&#34;&#34;Returns an expression without +- simplified with a leading coefficient (and perhaps *[...])&#34;&#34;&#34;
    prev = &#34;{&#34;
    const = 1
    var_pow = 0
    exp = []
    par = []
    exp_to_check = []
    par_to_check = {}
    for item_index in range(0, len(list_to_fix)):
        item = list_to_fix[item_index]
        if item_index + 1 == len(list_to_fix):
            next_i = &#34;}&#34;
        else:
            next_i = list_to_fix[item_index + 1]
        if (isinstance(item, str) and item in &#34;*/^&#34;) or (isinstance(prev, str) and prev == &#34;^&#34;):
            prev = item
            continue
        if prev == &#34;*&#34; or prev == &#34;{&#34;:
            sign = 1
        elif prev == &#34;/&#34;:
            sign = -1
        if item == &#34;X&#34;:
            if next_i == &#34;^&#34;:
                x_pow = list_to_fix[item_index + 2]
                if x_pow == &#34;X&#34; or isinstance(x_pow, list):
                    if sign == 1:
                        if len(exp) &gt; 0:
                            exp.append(&#34;*&#34;)
                    elif sign == -1:
                        if len(exp) == 0:
                            exp.append(1)
                        exp.append(&#34;/&#34;)
                    exp.extend([&#34;X&#34;, &#34;^&#34;, x_pow])
                    prev = item
                    continue
            else:
                x_pow = 1
            if isinstance(x_pow, int) or x_pow.isdigit():
                var_pow += sign * int(float(x_pow))
            else:
                var_pow += sign * float(x_pow)
        elif _is_float(item):
            if next_i == &#34;^&#34;:
                num_pow = list_to_fix[item_index + 2]
                if num_pow == &#34;X&#34;:
                    exp_to_check.append(item)
                    prev = item
                    continue
                elif isinstance(num_pow, list):
                    if sign == 1:
                        if len(exp) &gt; 0:
                            exp.append(&#34;*&#34;)
                    elif sign == -1:
                        if len(exp) == 0:
                            exp.append(1)
                        exp.append(&#34;/&#34;)
                    exp.extend([item, &#34;^&#34;, num_pow])
                    prev = item
                    continue
            else:
                num_pow = 1
            if sign == 1:
                const *= float(item) ** float(num_pow)
            elif sign == -1:
                const /= float(item) ** float(num_pow)
        elif isinstance(item, list) and prev != &#34;^&#34;:

            if next_i == &#34;^&#34; and not _is_float(list_to_fix[item_index + 2]):
                if sign == 1:
                    if len(par) &gt; 0:
                        par.append(&#34;*&#34;)
                elif sign == -1:
                    if len(par) == 0:
                        par.append(1)
                    par.append(&#34;/&#34;)
                if next_i == &#34;^&#34;:
                    par.extend([item, &#34;^&#34;, list_to_fix[item_index + 2]])
            else:
                if next_i == &#34;^&#34;:
                    extra = float(list_to_fix[item_index + 2])
                else:
                    extra = 1
                par_to_check[str(item)] = [item, par_to_check.setdefault(str(item), [[], 0])[1] + sign * extra]
        prev = item
    par_keys = sorted(par_to_check.keys())
    for dic_key in par_keys:
        if par_to_check[dic_key][1] == 0:
            continue
        elif par_to_check[dic_key][1] == 1:
            if len(par) &gt; 0:
                par.append(&#34;*&#34;)
            par.append(par_to_check[dic_key][0])
        elif par_to_check[dic_key][1] == -1:
            if len(par) == 0:
                par.append(1)
            par.extend([&#34;/&#34;] + [par_to_check[dic_key][0]])
        elif par_to_check[dic_key][1] &gt; 0:
            if len(par) &gt; 0:
                par.append(&#34;*&#34;)
            par.extend([par_to_check[dic_key][0]] + [&#34;^&#34;] + [str(par_to_check[dic_key][1])])
        else:
            if len(par) == 0:
                par.append(1)
            par.extend([&#34;/&#34;] + [par_to_check[dic_key][0]] + [&#34;^&#34;] + [str(-par_to_check[dic_key][1])])

    # simplifies exponents
    prev_check = []
    while prev_check != exp_to_check:
        prev_check = exp_to_check.copy()
        exp_to_check = sorted(exp_to_check)
        for dig_index in range(0, len(exp_to_check) - 1):
            cur_dig = exp_to_check[dig_index]
            next_dig = exp_to_check[dig_index + 1]
            if cur_dig == next_dig:
                if dig_index &gt; 0:
                    exp_to_check = exp_to_check[:dig_index] + exp_to_check[dig_index + 2:] + [str(float(cur_dig) *
                                                                                                  float(next_dig))]
                    break
                else:
                    exp_to_check = exp_to_check[dig_index + 2:] + [str(float(cur_dig) * float(next_dig))]
                    break
    if len(exp_to_check) == 1:
        if len(exp) == 0:
            exp = [exp_to_check[0], &#34;^&#34;, &#34;X&#34;]
        else:
            exp.extend([&#34;*&#34;, exp_to_check[0], &#34;^&#34;, &#34;X&#34;])
    elif len(exp_to_check) &gt; 1:
        if len(exp) &gt; 0:
            exp.append(&#34;*&#34;)
        for dig_index in range(0, len(exp_to_check)):
            exp.extend([exp_to_check[dig_index], &#34;^&#34;, &#34;X&#34;])
            if dig_index &lt; len(exp_to_check) - 1:
                exp.append(&#34;*&#34;)

    if const == 0:
        return [0]
    if len(exp) == 0:
        end = par
    elif len(par) == 0:
        end = exp
    else:
        end = exp + [&#34;*&#34;] + par
    if var_pow != 0:
        if len(end) &gt; 0:
            end = [&#34;*&#34;] + end
        if not var_pow == 1:
            end = [&#34;^&#34;, var_pow] + end
        end = [&#34;X&#34;] + end
    if len(end) &gt; 0:
        return [const, &#34;*&#34;] + end
    else:
        return [const]


def _is_int(string):
    if not isinstance(string, (str, int, float)):
        return False
    dot = False
    for char in str(string):
        if char not in &#34;1234567890.&#34;:
            return False
        if char == &#34;.&#34;:
            dot = True
        elif dot:
            if char != &#34;0&#34;:
                return False
    return True


def _is_float(string):
    if not isinstance(string, (str, int, float)):
        return False
    try:
        float(string)
        return True
    except ValueError:
        return False


def _replace_helper(expression, old_var, new_var, index):
    &#34;&#34;&#34;Help function for replace_var.&#34;&#34;&#34;
    if index == len(COMMON_OPERATORS):
        return expression.replace(old_var, new_var)
    else:
        sub_list = expression.split(COMMON_OPERATORS[index])
        for place in range(0, len(sub_list)):
            sub_list[place] = _replace_helper(sub_list[place], old_var, new_var, index + 1)
        return COMMON_OPERATORS[index].join(sub_list)


def _interp_expr(expression, variable, value=None):
    interp_expr = []
    curr = &#34;&#34;  # used to store numbers and common functions in one place
    prev_char = &#34;{&#34;  # signifies &#34;character&#34; before the first one
    add_par = 0
    to_check = replace_var(expression, variable, &#34;X&#34;).replace(&#34;[&#34;, &#34;(&#34;).replace(&#34;]&#34;, &#34;)&#34;)
    for index in range(0, len(to_check)):
        char = to_check[index]
        if char == &#34;(&#34; and prev_char in &#34;0123456789X)&#34; or char in &#34;0123456789X&#34; and prev_char == &#34;)&#34;:
            while add_par &gt; 0:
                interp_expr.append(&#34;)&#34;)
                add_par -= 1
            interp_expr.append(&#34;*&#34;)
        if char in &#34;&#34;.join(COMMON_OPERATORS):
            if prev_char not in &#34;&#34;.join(COMMON_OPERATORS).lower() + &#34;{&#34;:
                if prev_char in &#34;0123456789X)&#34;:
                    while add_par &gt; 0:
                        interp_expr.append(&#34;)&#34;)
                        add_par -= 1
                    interp_expr.append(&#34;*&#34;)
            curr += char
            if curr in COMMON_OPERATORS and (index + 1 == len(to_check) or (curr + to_check[index + 1]) not in
                                             COMMON_OPERATORS):
                interp_expr.append(curr)
                if not index + 1 == len(to_check) and not to_check[index + 1] == &#34;(&#34;:
                    interp_expr.append(&#34;(&#34;)
                    add_par += 1
                curr = &#34;&#34;
                prev_char = &#34;}&#34;  # signifies a common function
                continue
        elif char in &#34;0123456789.&#34;:
            if prev_char == &#34;X&#34;:
                interp_expr.append(&#34;^&#34;)
            curr += char
            if index + 1 == len(to_check) or not to_check[index + 1] in &#34;0123456789.&#34;:
                if _is_int(curr):
                    interp_expr.append(int(float(curr)))
                else:
                    interp_expr.append(float(curr))
                curr = &#34;&#34;
        elif char == &#34;X&#34;:
            if prev_char in &#34;1234567890X&#34;:
                interp_expr.append(&#34;*&#34;)
            if value is not None:
                interp_expr.append(str(value))
            else:
                interp_expr.append(variable)
        elif char in &#34;+-*/()^&#34;:
            if not char == &#34;^&#34;:
                while add_par &gt; 0:
                    interp_expr.append(&#34;)&#34;)
                    add_par -= 1
            interp_expr.append(char)
            curr = &#34;&#34;
        prev_char = char
    while add_par &gt; 0:
        interp_expr.append(&#34;)&#34;)
        add_par -= 1
    return interp_expr


def _check_expression(expr, variable):
    &#34;&#34;&#34;Checks whether the expr is a valid string expression of an arithmetic expression&#34;&#34;&#34;
    if not isinstance(expr, str):
        raise TypeError(&#34;Expression must be a string&#34;)
    if expr == &#34;&#34;:
        raise TypeError(&#34;Expression must be non empty&#34;)
    if not isinstance(variable, str):
        raise TypeError(&#34;Variable must be a string&#34;)
    for char in variable:
        if char in &#34;.0123456789()[]+-*^/{}\\\\&#34;:
            raise TypeError(&#34;Invalid variable &#34; + variable)
    for thing in [&#34;{&#34;, &#34;}&#34;]:
        if thing in expr:
            raise TypeError(&#34;Invalid character &#34; + thing + &#34; in expression &#34; + expr)
    simple_expr = expr
    for op in COMMON_OPERATORS:
        if op == variable.lower():
            raise TypeError(&#34;Invalid variable name &#34; + variable + &#34;. Protected operator.&#34;)
        simple_expr = simple_expr.replace(op, &#34;}&#34;)  # } signifies a common operator
    simple_expr = simple_expr.replace(variable, &#34;x&#34;).replace(&#34; &#34;, &#34;&#34;)
    parenthesis_list = []
    prev_char = &#34;{&#34;  # { signifies the &#34;character&#34; before the first character
    dot_allowed = True
    for char_index in range(0, len(simple_expr)):
        char = simple_expr[char_index]
        if char_index + 1 &lt; len(simple_expr):
            next_char = simple_expr[char_index+1]
        else:
            next_char = &#34;{&#34;
        if char not in &#34;.0123456789()[]+-*^/x{}&#34;:
            raise TypeError(&#34;Invalid character: &#34; + char + &#34; in expression &#34; + expr)
        if char in &#34;([&#34;:
            parenthesis_list.append(char)
        elif char in &#34;)]&#34;:
            if len(parenthesis_list) == 0:
                raise TypeError(&#34;Non matching parenthesis: &#34; + char + &#34; in expression &#34; + expr)
            if char == &#34;)&#34;:
                if not parenthesis_list.pop() == &#34;(&#34;:
                    raise TypeError(&#34;Non matching parenthesis: [ ... )&#34; + &#34; in expression &#34; + expr)
            else:
                if not parenthesis_list.pop() == &#34;[&#34;:
                    raise TypeError(&#34;Non matching parenthesis: ( ... ]&#34; + &#34; in expression &#34; + expr)
            if prev_char in &#34;.+-*/^}&#34;:
                raise TypeError(&#34;Invalid syntax: &#34; + prev_char.replace(&#34;}&#34;, &#34;...&#34;) + char + &#34; in expression &#34; +
                                expr)
            elif prev_char in &#34;([&#34;:
                raise TypeError(&#34;Empty parenthesis: &#34; + char + prev_char + &#34; in expression &#34; + expr)
        elif char in &#34;^*/&#34; and prev_char == &#34;{&#34;:
            raise TypeError(&#34;Invalid starting operator: &#34; + char + &#34; in expression &#34; + expr)
        elif char in &#34;+-*/^&#34; and prev_char in &#34;+-*/^[}.&#34;:
            raise TypeError(&#34;Invalid operator usage: &#34; + prev_char.replace(&#34;}&#34;, &#34;...&#34;) + char + &#34; in expression &#34;
                            + expr)
        elif char in &#34;*/&#34; and prev_char == &#34;(&#34;:
            raise TypeError(&#34;Invalid operator usage: &#34; + prev_char + char + &#34; in expression &#34; + expr)
        elif char == &#34;.&#34;:
            if not dot_allowed:
                raise TypeError(&#34;Two decimal points in one number in expression: &#34; + expr)
            else:
                dot_allowed = False
        elif prev_char == &#34;^&#34; and (next_char == &#34;^&#34; or char == &#34;x&#34; and next_char in &#34;1234567890.&#34;):
            raise TypeError(&#34;Unclear use of exponent: &#34; + prev_char + char + next_char + &#34; in: &#34; + expr)
        if char in &#34;+-*^/()[]x}&#34;:
            dot_allowed = True
        prev_char = char
    if simple_expr[-1] in &#34;+-*/^}.&#34;:
        raise TypeError(&#34;Invalid ending operator in expression &#34; + expr)
    if not len(parenthesis_list) == 0:
        raise TypeError(&#34;Missing &#34; + str(len(parenthesis_list)) + &#34; ending parenthesis&#34; + &#34; in expression &#34; + expr)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="symbol_math.derivative"><code class="name flex">
<span>def <span class="ident">derivative</span></span>(<span>expression, variable)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the derivative of the expression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>string</code></dt>
<dd>Original expression.</dd>
<dt><strong><code>variable</code></strong> :&ensp;<code>string</code></dt>
<dd>Variable used in expression</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Derivative of expression.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>expression not recognisable as algebraic expression or variable name equal to protected function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivative(expression, variable):
    &#34;&#34;&#34;Takes the derivative of the expression.
    Args:
        expression (string): Original expression.
        variable (string): Variable used in expression
    Returns:
        string: Derivative of expression.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
    &#34;&#34;&#34;
    _check_expression(expression, variable)
    expr_list = _der_helper(_interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;))
    return _fix_out(expr_list, variable)</code></pre>
</details>
</dd>
<dt id="symbol_math.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>expression, variable, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the expression with given variable at value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>string</code></dt>
<dd>The expression that should be simplified.</dd>
<dt><strong><code>variable</code></strong> :&ensp;<code>string</code></dt>
<dd>Used variable in expression</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int</code></dt>
<dd>Value where function should be evaluated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>evaluation of function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>expression not recognisable as algebraic expression or variable name equal to protected function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(expression, variable, value):
    &#34;&#34;&#34;Evaluates the expression with given variable at value.
    Args:
        expression (string): The expression that should be simplified.
        variable (string): Used variable in expression
        value (float, int): Value where function should be evaluated
    Returns:
        float: evaluation of function.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function&#34;&#34;&#34;
    if not isinstance(value, (float, int)):
        raise TypeError(&#34;Input value must be float or int&#34;)
    _check_expression(expression, variable)
    interp = _interp_expr(expression, variable, value)
    for index in range(0, len(interp)):
        thing = str(interp[index])
        if thing == &#34;^&#34;:
            interp[index] = &#34;**&#34;
        elif thing in COMMON_OPERATORS:
            interp[index] = &#34;math.&#34; + thing
        else:
            interp[index] = thing
    try:
        return float(eval(&#34;&#34;.join(interp)))
    except ZeroDivisionError:
        raise ZeroDivisionError(&#34;float division by zero for expression: &#34; + expression + &#34; at &#34; + variable + &#34; = &#34; +
                                str(value))</code></pre>
</details>
</dd>
<dt id="symbol_math.replace_var"><code class="name flex">
<span>def <span class="ident">replace_var</span></span>(<span>expression, old_var, new_var)</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces old variable in expression with a new one, without changing built in functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>string</code></dt>
<dd>The expression that should be simplified.</dd>
<dt><strong><code>old_var</code></strong> :&ensp;<code>string</code></dt>
<dd>Old variable in expression</dd>
<dt><strong><code>new_var</code></strong> :&ensp;<code>string</code></dt>
<dd>New variable to be used</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>updated expression</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_var(expression, old_var, new_var):
    &#34;&#34;&#34;Replaces old variable in expression with a new one, without changing built in functions.
    Args:
        expression (string): The expression that should be simplified.
        old_var (string): Old variable in expression
        new_var (string): New variable to be used
    Returns:
        string: updated expression
    &#34;&#34;&#34;
    return _replace_helper(expression, old_var, new_var, 0)</code></pre>
</details>
</dd>
<dt id="symbol_math.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>expression, variable)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplifies expression to simplest form.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>string</code></dt>
<dd>The expression that should be simplified.</dd>
<dt><strong><code>variable</code></strong> :&ensp;<code>string</code></dt>
<dd>Used variable in expression</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>simplified expression.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>expression not recognisable as algebraic expression or variable name equal to protected function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(expression, variable):
    &#34;&#34;&#34;Simplifies expression to simplest form.
    Args:
        expression (string): The expression that should be simplified.
        variable (string): Used variable in expression
    Returns:
        string: simplified expression.
    Raises:
        TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
    &#34;&#34;&#34;
    _check_expression(expression, variable)
    expr_list = _simp_helper(_interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;))
    return _fix_out(expr_list, variable)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="symbol_math.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>expression, variable)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for storing functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>string</code></dt>
<dd>The functions expression. Must be an algebraic expression</dd>
<dt><strong><code>variable</code></strong> :&ensp;<code>string</code></dt>
<dd>The function variable</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>expression not recognisable as algebraic expression or variable name equal to protected function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function(object):
    &#34;&#34;&#34;A class for storing functions.


    &#34;&#34;&#34;

    def __init__(self, expression, variable):
        &#34;&#34;&#34;
        Args:
            expression (string): The functions expression. Must be an algebraic expression
            variable (string): The function variable
        Raises:
            TypeError: expression not recognisable as algebraic expression or variable name equal to protected function
        &#34;&#34;&#34;
        _check_expression(expression, variable)
        self._expression = _interp_expr(replace_var(expression, variable, &#34;X&#34;), &#34;X&#34;)
        self.variable = variable

    def simplify(self):
        &#34;&#34;&#34;Simplifies expression to simplest form.
        Returns:
            string: new expression for function
            &#34;&#34;&#34;
        self._expression = _simp_helper(self._expression)
        return self

    def evaluate(self, value):
        &#34;&#34;&#34;Evaluates the function at specified value
        Args:
            value (float, int): Value where function should be evaluated
        Returns:
            float: function evaluation
        &#34;&#34;&#34;
        return evaluate(str(self), self.variable, value)

    def change_variable(self, variable):
        &#34;&#34;&#34;Changes the current function variable to the given variable.
        Args:
            variable (string): New variable for function
        Returns:
            string: New function expression
        &#34;&#34;&#34;
        self.variable = variable
        return self

    def __add__(self, other):
        &#34;&#34;&#34;Addition operator for two functions of the same variables.
        Overloads + operator as addition defined for functions.
        Args:
            other (Function): Other function to be added
        Returns:
            object: the function that is the sum of self and other
        Raises:
             TypeError: If other.variable != self.variable
         &#34;&#34;&#34;
        if other.variable != self.variable:
            raise TypeError(&#34;Functions must have the same variable&#34;)
        return Function(str(self) + &#34;+&#34; + str(other), self.variable)

    def __str__(self):
        &#34;&#34;&#34;String representation.
        Overloads str operator with function expression&#34;&#34;&#34;
        return _fix_out(self._expression, self.variable)

    def derivative(self):
        &#34;&#34;&#34;Calculate derivative of function
        Returns:
            object: the function derivative
        Raises:
             SystemError: Cannot compute derivative internally
         &#34;&#34;&#34;
        der = Function(&#34;1&#34;, self.variable)
        der._expression = _der_helper(self._expression)
        return der

    def finite_integration(self, lower_bound, upper_bound, tol=0.01):
        &#34;&#34;&#34;Calculate derivative of function
        Args:
            lower_bound (float): lower integration bound
            upper_bound (float): upper integration bound
            tol (float): error tolerance for calculation. Must be non-negative
        Returns:
            float: integral of self over lower_bound to upper_bound
        Raises:
            TypeError: If either lower_bound, upper_bound or tol is not of type float
            ValueError: If tol &lt; 0
         &#34;&#34;&#34;
        for arg in [lower_bound, upper_bound, tol]:
            if not isinstance(arg, (float, int)):
                raise TypeError(&#34;Arguments must be floats or ints&#34;)
        if tol &lt; 0:
            raise ValueError(&#34;tol must be positive, not &#34; + str(tol))
        val, prev_val = 0, tol + 1
        exp = 1
        while abs(prev_val-val) &gt; tol:
            prev_val = val
            exp += 1
            n = 10 ** exp
            part_sum = (self.evaluate(lower_bound) + self.evaluate(upper_bound))/2/n
            for k in range(1, n):
                point = lower_bound + k/n* (upper_bound-lower_bound)
                part_sum += self.evaluate(point) * 1/n
            val = part_sum
        return val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="symbol_math.Function.change_variable"><code class="name flex">
<span>def <span class="ident">change_variable</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the current function variable to the given variable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong> :&ensp;<code>string</code></dt>
<dd>New variable for function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>New function expression</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_variable(self, variable):
    &#34;&#34;&#34;Changes the current function variable to the given variable.
    Args:
        variable (string): New variable for function
    Returns:
        string: New function expression
    &#34;&#34;&#34;
    self.variable = variable
    return self</code></pre>
</details>
</dd>
<dt id="symbol_math.Function.derivative"><code class="name flex">
<span>def <span class="ident">derivative</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate derivative of function</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>the function derivative</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SystemError</code></dt>
<dd>Cannot compute derivative internally</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivative(self):
    &#34;&#34;&#34;Calculate derivative of function
    Returns:
        object: the function derivative
    Raises:
         SystemError: Cannot compute derivative internally
     &#34;&#34;&#34;
    der = Function(&#34;1&#34;, self.variable)
    der._expression = _der_helper(self._expression)
    return der</code></pre>
</details>
</dd>
<dt id="symbol_math.Function.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the function at specified value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int</code></dt>
<dd>Value where function should be evaluated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>function evaluation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, value):
    &#34;&#34;&#34;Evaluates the function at specified value
    Args:
        value (float, int): Value where function should be evaluated
    Returns:
        float: function evaluation
    &#34;&#34;&#34;
    return evaluate(str(self), self.variable, value)</code></pre>
</details>
</dd>
<dt id="symbol_math.Function.finite_integration"><code class="name flex">
<span>def <span class="ident">finite_integration</span></span>(<span>self, lower_bound, upper_bound, tol=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate derivative of function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lower_bound</code></strong> :&ensp;<code>float</code></dt>
<dd>lower integration bound</dd>
<dt><strong><code>upper_bound</code></strong> :&ensp;<code>float</code></dt>
<dd>upper integration bound</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>error tolerance for calculation. Must be non-negative</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>integral of self over lower_bound to upper_bound</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If either lower_bound, upper_bound or tol is not of type float</dd>
<dt><code>ValueError</code></dt>
<dd>If tol &lt; 0</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finite_integration(self, lower_bound, upper_bound, tol=0.01):
    &#34;&#34;&#34;Calculate derivative of function
    Args:
        lower_bound (float): lower integration bound
        upper_bound (float): upper integration bound
        tol (float): error tolerance for calculation. Must be non-negative
    Returns:
        float: integral of self over lower_bound to upper_bound
    Raises:
        TypeError: If either lower_bound, upper_bound or tol is not of type float
        ValueError: If tol &lt; 0
     &#34;&#34;&#34;
    for arg in [lower_bound, upper_bound, tol]:
        if not isinstance(arg, (float, int)):
            raise TypeError(&#34;Arguments must be floats or ints&#34;)
    if tol &lt; 0:
        raise ValueError(&#34;tol must be positive, not &#34; + str(tol))
    val, prev_val = 0, tol + 1
    exp = 1
    while abs(prev_val-val) &gt; tol:
        prev_val = val
        exp += 1
        n = 10 ** exp
        part_sum = (self.evaluate(lower_bound) + self.evaluate(upper_bound))/2/n
        for k in range(1, n):
            point = lower_bound + k/n* (upper_bound-lower_bound)
            part_sum += self.evaluate(point) * 1/n
        val = part_sum
    return val</code></pre>
</details>
</dd>
<dt id="symbol_math.Function.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplifies expression to simplest form.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>new expression for function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self):
    &#34;&#34;&#34;Simplifies expression to simplest form.
    Returns:
        string: new expression for function
        &#34;&#34;&#34;
    self._expression = _simp_helper(self._expression)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="symbol_math.derivative" href="#symbol_math.derivative">derivative</a></code></li>
<li><code><a title="symbol_math.evaluate" href="#symbol_math.evaluate">evaluate</a></code></li>
<li><code><a title="symbol_math.replace_var" href="#symbol_math.replace_var">replace_var</a></code></li>
<li><code><a title="symbol_math.simplify" href="#symbol_math.simplify">simplify</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="symbol_math.Function" href="#symbol_math.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="symbol_math.Function.change_variable" href="#symbol_math.Function.change_variable">change_variable</a></code></li>
<li><code><a title="symbol_math.Function.derivative" href="#symbol_math.Function.derivative">derivative</a></code></li>
<li><code><a title="symbol_math.Function.evaluate" href="#symbol_math.Function.evaluate">evaluate</a></code></li>
<li><code><a title="symbol_math.Function.finite_integration" href="#symbol_math.Function.finite_integration">finite_integration</a></code></li>
<li><code><a title="symbol_math.Function.simplify" href="#symbol_math.Function.simplify">simplify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>